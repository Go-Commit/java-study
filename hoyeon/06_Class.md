## 객체지향 프로그래밍

#### 객체
자신의 속성을 가지고 있고 다른 것과 식별 가능한 것  
속성(filed)과 동작(method)로 구성됨

#### 객체의 상호작용
객체들들 각각 독립적으로 존재하고, 메소드를 통해 다른 객체와 서로 상호작용
메소드 호출은 다음과 같은 형태를 가지고 있다.  
```리턴값 = 객체.메소드(매개값1, ...);```

#### 객체 간의 관계
* 집합 관계 : 하나는 부품, 하나는 완성품 (자동차와 엔진)  
* 사용 관계 : 객체 간의 상호작용 (사람과 자동차)
* 상속 관계 : 상위 객체를 기반으로 하위 객체 생성 (기계와 자동차)

#### 객체 지향 프로그래밍의 특징
* 캡슐화
  * 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
  * 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는 목적
  * 접근 제한자를 통해 객체의 필드와 메소드의 사용 범위를 제한하여 보호
* 상속
  * 상위 객체가 자신이 가진 필드와 메소드를 하위 객체에 물려주어 하위 객체가 사용할 수 있도록 하는 것
  * 반복된 코드의 중복을 줄여주어 하위 객체를 쉽고 빠르게 설계할 수 있으며, 유지 보수 시간을 최소화함
* 다형성
  * 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질
  * 다형성의 효과로 객체는 부품화가 가능
  

## 객체와 클래스

* 클래스
  * 객체를 만들기 위한 설계도
  * 객체를 생성하기 위한 필드와 메소드가 정의되어 있음
  * 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다.


## 클래스 선언

클래스 이름은 다른 클래스와 식별해야 하므로 규칙에 따라 만든다.
1. 하나 이상의 문자로 이루어져야 한다.
2. 첫번쨰 글자는 숫자가 될 수 없다.
3. $, _ 외의 특수 문자는 사용할 수 없다.
4. 자바키워드는 사용할 수 없다.

클래스 이름을 정했다면 "클래스이름.java"로 소스 파일을 생성 한 후 클래스를 선언한다.  
```
public class 클래스이름 {
}
```


## 객체 생성과 클래스 변수

클래스로부터 객체를 생성하려면 new 연산자를 사용한다.  
```
new 클래스();
```


## 클래스의 구성 멤버

#### 필드
객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳 
```
int fieldName;
```

#### 생성자
객체 생성 시 초기화를 담당
```
ClassName() {...}
```

#### 메소드
객체의 동장에 해당하는 실행 블록
```
void methodName() {...}
```

#### 생성자 오버로딩
다양한 방법으로 객체를 생성할 수 있도록 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
```
Car car1 = new Car();
Car car1 = new Car('그랜저');
Car car1 = new Car('그랜저', '흰색');
Car car1 = new Car('그랜저', '흰색', 300);
```

#### 다른 생성자 호출 (this())
자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.
```
Car() {}
Car(String mdoel) {
  this(model, '흰색', 300);
}
Car(String mdoel, String color) {
  this(model, color, 300);
}
Car(String mdoel, String color, int maxSpeed) {
  this.model = model;
  this.color = color;
  this.maxSpeed = maxSpeed;
}
```

## 메소드

#### 메소드 선언
* 리턴타입
  * 리턴값이 없는 메소드는 리턴 타입에 void가 와야한다. ```void powerOn() {...}```
  * 리턴값이 있는 메소드는 리턴값의 타입이 와야 한다. ```double divide(int x, int y) {...}```

#### 메소드 호출
* 객체 내부에서 호출  
```
메소드(매개값, ...);
타입 변수 = 메소드(매개값, ...);
```  
* 객체 외부에서 호출
  * 클래스로부터 객체를 생성 후 메소드를 호출한다.
```
클래스 참조변수 = new 클래스(매개값, ...);
참조변수.메소드(매개값, ...);
타입 변수 = 참조변수.메소드(매개값, ...);
```

#### 메소드 오버로딩
클래스 내의 같은 이름의 메소드를 여러 개 선언하는 것


## 인스턴스 멤버와 this

인스틴스 멤버란 객체(인스턴스)를 생성 후 사용할 수 있는 필드와 메소드를 말한다.  
객체 외부에서 인스턴스 멤버에게 접근하기 위해 참조변수를 사용하는 것처럼 객체 내부에서도 인스턴스 멤버에게 접근하기 위해 this를 사용할 수 있다.


## 정적 멤버와 static

객체를 생성하지 않고 사용할 수 있는 필드와 메소드

#### 정적 멤버 선언
```
public class 클래스 {
  // 정적 필드
  static 타입필드;
  // 정적 메소드
  staticc 리턴 타입 메솓( 매개변수선언, ...) { ... };
```

#### 정적 멤버 사용
```
클래스.필드;
클래스.메소드( 매개값, ... );
```

### 정적 초기화 블록
정적 필드는 객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 있다.  
정적 필드를 위한 초기화 작업은 정적 블록에서 할 수 있따.
```
statis {
  ...
}
```

#### 정적 메소드와 블록 선언 시 주의할 점
개체가 없어도 실행된다는 특징 때문에, 이들 내부에서는 인스턴스 메소드를 사용할 수 없으며, this 키워드도 사용할 수 없다.

#### 싱글톤
전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 할 떄 이 객체를 싱글톤이라고 한다.  
싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.  
즉, 생성자 앞에 private 접근 제한자를 붙여준다. 


## final 필드와 상수

#### final 필드
프로그램 실행 도중에 수정 불가
```
final 타입 필드;
```
final 필드에서 초기값을 주는 방법은 필드 선언시 주거나 생성자에서 주어야 한다.

#### 상수
불변의 값  
final 필드와는 달리 객체마다 저장할 필요가 없는 공용성을 띠고 있다.
```
static final 타입 상수;
```


## 패키지

클래스를 체계적으로 관리하기 위해 사용  
패키지는 클래스를 유일하게 만들어주는 식별자 역할  
```
상위패키지.하위패키지.클래스
```


## 접근 제한자

|접근 제한|적용 대상|접근할 수 없는 클래스|
|---|---|---|
|public|클래스, 필드, 생성자, 메소드|없음|
|protected|필드, 생성자, 메소드|자식 클래스가 아닌 다른 패키지에 소속된 클래스|
|default|클래스, 필드, 생성자, 메소드|다른 패키지에 소속된 클래스|
|private|필드, 생성자, 메소드|모든 외부 클래스|


## Getter와 Setter 메소드

* Setter : 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도
* Getter : 객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우, 메소드로 필드값을 가공한 후 외부로 전달


## 어노테이션

컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보  
```@AnnotationName```
* 컴파일러에게 코드 문법 에러를 체크하도록 정보 제공
* 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자도응로 생성할 수 있도록 정보 제공
* 실행 시 특정 기능을 실행하도록 정보 제공
